package com.maxim.pos.sales.service;

import java.sql.Connection;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.stream.IntStream;

import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.maxim.pos.common.entity.BranchInfo;
import com.maxim.pos.common.entity.BranchScheme;
import com.maxim.pos.common.entity.SchemeInfo;
import com.maxim.pos.common.entity.TaskJobLog;
import com.maxim.pos.common.enumeration.PollSchemeType;
import com.maxim.pos.common.service.PosSystemService;
import com.maxim.pos.common.util.JDBCUtils;
import com.maxim.pos.common.util.LogUtils;


/**
 * Class SalesServiceSqlImpl
 * 
 * Created by Tommy Leung
 * Created on 12 Apr 2017
 *  
 * Amendment History
 * 
 * Name                  Modified on  Comment
 * --------------------  -----------  ----------------------------------------
 * 
 * 
 */


@Service("sqlSalesService")
public class SalesServiceSqlImpl extends  SalesServiceBaseImpl {
	
    @Autowired
	private PosSystemService posSystemService;

	@Override
    protected int getDefaultScanDayIfNoControl()
	{
		return sqlDefaultScanDayIfNoControl ;
	}
	@Override
    protected int getMaxScanDay()
    {
		return sqlMaxScanDay ;
    }

	@Override
	protected List<Date> doGetPosProcessDate(BranchScheme branchScheme, List<SchemeInfo> schemeList,
			java.sql.Date currentDate, java.sql.Date yesterdayDate, java.sql.Date controlDate, Logger logger) {
		
    	return  posSystemService.getPosEODBusinessDateList(branchScheme,controlDate,logger);
	}



	@Override
	protected List<Date> doProcessPosDataToStg(BranchScheme branchScheme, List<SchemeInfo> schemeList,
			List<Date> procDates, java.sql.Date currentDate, java.sql.Date yesterdayDate, java.sql.Date controlDate,
			TaskJobLog taskJobLog, Logger logger) {

        PollSchemeType pollSchemeType	= branchScheme.getPollSchemeType();
        BranchInfo branchInfo			= branchScheme.getBranchInfo();
        String branchCode				= branchScheme.getBranchMaster().getBranchCode();
        
		int totalCount = 0;
        try (Connection toConn = applicationSettingService.getCurrentJDBCConnection(); 
        		Connection fromConn = applicationSettingService.getJDBCConection(branchInfo, true)) {
        	
            LogUtils.printLog(logger, "{} {} Ready to copy data from: \r\ndatasource: '{}' to \r\n datasource: '{}'", branchCode, pollSchemeType, fromConn, toConn);

            // Real Time (SQL Server)
            // Lookup the table name configured in database.
            // Get the records with status = '' and specific branch code
            if (PollSchemeType.SALES_REALTIME.equals(pollSchemeType)) {
            	
                LogUtils.printLog(logger, "{} REAL_TIME processSqlToStg {} ", branchCode, schemeList.size());

                String[] conditions = {" LTRIM(RTRIM(status)) = \'P'", " branch_code  = \'" + branchCode + "\'"};
                for (SchemeInfo schemeInfo : schemeList) 
                {
                    String fromTable = schemeInfo.getSource();
                    String toTable = schemeInfo.getDestination();
                    try 
                    {
                    	// Update the record to Pending State '' -> 'P'
                    	int row = JDBCUtils.updatePendingStatusByBranchCodeAndStatus(fromConn, fromTable, branchCode,"");
                        LogUtils.printLog(logger, "{} REAL_TIME schemeInfo{} row:{} : {} -> {} ", branchCode, schemeInfo.getId(), row, schemeInfo.getSource(), schemeInfo.getDestination());
                        if (row > 0)
                        {
                            int[] returnInts = {0,0};
	                        if (schemeInfo.isConsistentStructure()) {
	                        	returnInts = JDBCUtils.structureConsistentBulkCopy(fromConn
	                            		,toConn
	                            		,schemeInfo
	                            		,defaultTransactionBatchSize
	                            		,conditions);
	                        	returnInts = new int[]{returnInts[0], returnInts[1], row, returnInts[0]+returnInts[1]};
	                        } else {
	                        	returnInts = JDBCUtils.bulkCopyFromSQLConn(fromConn, toConn, schemeInfo, null, null, conditions);
	                        	returnInts = new int[]{returnInts[0], returnInts[1], row, returnInts[0]+returnInts[1]};
	                        }
                            LogUtils.printLog(logger, "{} REAL_TIME schemeInfo{} insert records: {}; update records:{} ", branchCode, schemeInfo.getDestination(), returnInts);
                            taskJobLogService.createJobLogDetail(taskJobLog, fromTable, toTable, 0, returnInts);

                            // format checkSum criteria for POS data process (status
                            // = 'P', and branchCode = pos branch)
                            boolean passCheckSum = JDBCUtils.checkSumBySchemeInfo(fromConn, toConn, branchCode, schemeInfo,
                                    conditions);
                            LogUtils.printLog(logger, "{} REAL_TIME schemeInfo{} passCheckSum {}", branchCode, schemeInfo.getDestination(), passCheckSum);
                            if (!passCheckSum) {
                                throw new RuntimeException("checkSumColumn false");
                            }

                            // Update Status to 'C'
                            if (IntStream.of(returnInts).sum() > 0) {
                                int count = JDBCUtils.updateCompleteStatusByBranchCodeAndStatus(fromConn, fromTable, branchCode,"P");
                                LogUtils.printLog(logger, "{} REAL_TIME schemeInfo{} completeRecord {}", branchCode, schemeInfo.getDestination(),count);
                                
                            	totalCount +=row ;
    						}
                        }
                    } catch (Exception e) {
                        LogUtils.printException(logger, "Task execte exception: ", e);
                        taskJobLogService.createJobExceptionDetail(taskJobLog, fromTable, toTable, e);
                    }
                }
            } else if (PollSchemeType.SALES_EOD.equals(pollSchemeType)) {
            	
                LogUtils.printLog(logger, "{} SALES_EOD processSqlToStg {} ", branchCode, schemeList.size());

            	int idx = 0;
            	SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");
            	StringBuffer dateStrBuf = new StringBuffer("(");
            	String minDate	= null ;
            	String maxDate	= null ;
            	for (Date date : procDates)
            	{
            		if (idx == 0)
            		{
            			minDate=df.format(date);
            		}
            		dateStrBuf.append("'").append(df.format(date));
            		if (++idx == procDates.size())
            		{
            			dateStrBuf.append("')");
            		}
            		else
            		{
            			dateStrBuf.append("',");
            		}
            		if (idx == procDates.size())
            		{
            			maxDate=df.format(date);
            		}
            	}
            	
            	StringBuffer dateConditionStrBuf = new StringBuffer("CONVERT(varchar(16),business_date,23) in ").append(dateStrBuf);
            	String dateConditionStr = dateConditionStrBuf.toString();
            	String deleteDateConditionStr = "CONVERT(varchar(16),business_date,23) >= '"+minDate+"' and CONVERT(varchar(16),business_date,23) <= '"+maxDate+"'"; 
            	
                String[] conditions = new String[]{" branch_code  = \'" + branchCode + "\'",
                		dateConditionStr};
                
                for (SchemeInfo schemeInfo : schemeList) {
                    
                    LogUtils.printLog(logger, "{} SALES_EOD schemeInfo{}  : {} -> {} ", branchCode, schemeInfo.getId(), schemeInfo.getSource(), schemeInfo.getDestination());

                    String fromTable = schemeInfo.getSource();
                    String toTable = schemeInfo.getDestination();
                    
                    try {
                        int[] returnInts = {0,0};
                        int deleteCount = JDBCUtils.deleteByBranchAndBizDate(toConn, schemeInfo.getDestination(),
                    			branchScheme.getBranchMaster().getBranchCode(), deleteDateConditionStr);
                        LogUtils.printLog(logger, "{} SALES_EOD schemeInfo{} delete table :{} {} ", branchCode, schemeInfo.getDestination(), deleteCount, deleteDateConditionStr);

                        if (schemeInfo.isConsistentStructure()) {
                        	returnInts = JDBCUtils.structureConsistentBulkCopy(fromConn
                            		,toConn
                            		,schemeInfo
                            		,defaultTransactionBatchSize
                            		, conditions
                            		, false);
                        } 
                        else 
                        {
                        	returnInts = JDBCUtils.bulkCopyFromSQLConn(fromConn, toConn, schemeInfo, defaultTransactionBatchSize, null, conditions);
                        }
                        LogUtils.printLog(logger, "{} SALES_EOD schemeInfo{} insert records: {}; update records:{} ", branchCode, schemeInfo.getDestination(), returnInts);

                        // Update the Pos Status to Complete(C) 
//                        int updateCount = JDBCUtils.updateCompleteStatusByBranchCodeAndStatus(fromConn, fromTable, branchCode, "P");
//        				LogUtils.printLog(logger, " {} Branch update Source Status Count : {}", branchCode, updateCount) ;
                        
                        // Create Job Log Detail for each Table
        				taskJobLogService.createJobLogDetail(taskJobLog, fromTable, toTable, deleteCount, returnInts);

                        // format checkSum criteria for POS data process branchCode = pos branch)
                        boolean passCheckSum = JDBCUtils.checkSumBySchemeInfo(fromConn, toConn, branchCode, schemeInfo,
                                conditions);
                        LogUtils.printLog(logger, "{} SALES_EOD schemeInfo{} passCheckSum {}", branchCode, schemeInfo.getDestination(), passCheckSum);
                        if (!passCheckSum) {
                            throw new RuntimeException("checkSumColumn false");
                        }

                    } catch (Exception e) {
                        LogUtils.printException(logger, "Task execte exception: ", e);
                        taskJobLogService.createJobExceptionDetail(taskJobLog, fromTable, toTable, e);
                    }
                }
            }
        } catch(Exception e) {
        	e.printStackTrace();
        	LogUtils.printException(logger, "get connection is null",e);
        	taskJobLogService.createJobExceptionDetail(taskJobLog, "", "", e);
        	procDates = null;
        }
        LogUtils.printLog(logger, "{} {} {} {}", branchCode, pollSchemeType, branchScheme.getDirection(), branchScheme.getPollSchemeName());
        
        if (PollSchemeType.SALES_REALTIME.equals(pollSchemeType)) {
        
        	if (totalCount <= 0)
        	{
        		return null;
        	}
        	else
        	{
        		return new ArrayList<Date>();
        	}
        }

        return procDates ;
	}



}
