package com.maxim.pos.common.service;

import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.Date;
import java.util.List;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;
import com.maxim.pos.common.entity.ApplicationSetting;
import com.maxim.pos.common.entity.BranchScheme;
import com.maxim.pos.common.entity.SchemeJobLog;
import com.maxim.pos.common.entity.SchemeScheduleJob;
import com.maxim.pos.common.enumeration.JobProcessStatus;
import com.maxim.pos.common.enumeration.LatestJobInd;
import com.maxim.pos.common.util.LogUtils;
import com.maxim.pos.common.util.PollThreadPoolExecutor;

@Service("schemeQuartzTaskExecutor")
public class SchemeQuartzTaskExecutor {
    public static final Logger LOGGER = LoggerFactory.getLogger(SchemeQuartzTaskExecutor.class);
    //	private static ExecutorService EXECUTOR_SERVICE;
    private static PollThreadPoolExecutor pool;
    @Autowired
    private PollBranchSchemeService pollBranchSchemeService;
    @Autowired
    private SchedulerJobLogService schedulerJobLogService;
    @Autowired
    private PosSystemService posSystemService;
    @Autowired
    private ApplicationSettingService applicationSettingService;

    @PostConstruct
    public void init() throws Exception {
        ApplicationSetting applicationSetting = applicationSettingService
                .findApplicationSettingByCode("BRANCH_EXECUTE_THREADPOOL_SIZE");
        int poolSize = 100;
        if (applicationSetting != null) {
            String pool = applicationSetting.getCodeValue();
            try {
                poolSize = Integer.parseInt(pool);
            } catch (Exception e) {
                LOGGER.error("BRANCH_EXECUTE_THREADPOOL config Error,must number", e);
            }
        }
        pool = new PollThreadPoolExecutor(poolSize, poolSize, 60,
                TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());

    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void execute(SchemeScheduleJob scheduleJob) {

        Logger logger = null;
        SchemeJobLog schemeJobLog = null;
        try {
            switch (scheduleJob.getPollSchemeType()) {
                case SALES_REALTIME:
                    logger = LogUtils.SALES_REALTIME_LOGGER;
                    break;
                case SALES_EOD:
                    logger = LogUtils.SALES_EOD_LOGGER;
                    break;
                case MASTER:
                    logger = LogUtils.MASTER_LOGGER;
                    break;
                case SMTP:
                    logger = LogUtils.MASTER_LOGGER;
                    break;
                default:
                    logger = LOGGER;
                    break;
            }

            if (!scheduleJob.isEnable()) {
                LogUtils.printLog(logger,
                        "job is not enable : jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                        scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                        scheduleJob.getPollSchemeDirection());
                return;
            }

            LogUtils.printLog(logger,
                    "job execute start... jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                    scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                    scheduleJob.getPollSchemeDirection());
            schemeJobLog = checkJobLog(scheduleJob, logger);
            if (schemeJobLog == null) {
                return;
            }

            List<BranchScheme> branchSchemes = pollBranchSchemeService.getBranchSchemeByScheduleJob(scheduleJob);

            BranchSchemeExecutor branchSchemeExecutor;
            int numberOfRecordProcessed = 0;
            for (BranchScheme branchScheme : branchSchemes) {
                if (!branchScheme.isEnabled()) {
                    LogUtils.printLog(logger, "branchScheme is not enable :{}=={}=={}", branchScheme.getId(),
                            branchScheme.getPollSchemeName(),branchScheme.getPollSchemeType());
                    continue;
                } else if (!branchScheme.getBranchInfo().isEnable()) {
                    LogUtils.printLog(logger, "BranchInfo is not enable :{}=={}", branchScheme.getBranchInfo().getId(),
                            branchScheme.getBranchInfo().getClientDB());
                    continue;
                }
//                } else {
//                    LocalDateTime now = LocalDateTime.now();
//                    LocalDateTime start = branchScheme.getStartTime().toInstant().atZone(ZoneId.systemDefault())
//                            .toLocalDateTime();
//                    LocalDateTime end = branchScheme.getEndTime().toInstant().atZone(ZoneId.systemDefault())
//                            .toLocalDateTime();
//                    if (now.isBefore(start) || now.isAfter(end)) {
//                        LogUtils.printLog(logger, "branchScheme {}=={}=={}  invald execute datetime: startTime={},endTime={}",
//                                branchScheme.getId(),
//                                branchScheme.getPollSchemeName(),
//                                branchScheme.getPollSchemeType(),
//                                branchScheme.getStartTime(),
//                                branchScheme.getEndTime());
//                        continue;
//                    }
//
//                }

				LocalDateTime now = LocalDateTime.now();
				if (branchScheme.getStartTime() != null)
				{
					LocalDateTime start = branchScheme.getStartTime().toInstant().atZone(ZoneId.systemDefault())
							.toLocalDateTime();
					if (now.isBefore(start) ) {
                        LogUtils.printLog(logger, "branchScheme {}=={}=={}  invald execute datetime: startTime={},endTime={}",
                                branchScheme.getId(),
                                branchScheme.getPollSchemeName(),
                                branchScheme.getPollSchemeType(),
                                branchScheme.getStartTime(),
                                branchScheme.getEndTime());
						continue;
					}
				}
				if (branchScheme.getEndTime() != null)
				{
					LocalDateTime end = branchScheme.getEndTime().toInstant().atZone(ZoneId.systemDefault())
							.toLocalDateTime();
					if ( now.isAfter(end)) {
                        LogUtils.printLog(logger, "branchScheme {}=={}=={}  invald execute datetime: startTime={},endTime={}",
                                branchScheme.getId(),
                                branchScheme.getPollSchemeName(),
                                branchScheme.getPollSchemeType(),
                                branchScheme.getStartTime(),
                                branchScheme.getEndTime());
						continue;
					}
				}

                branchScheme.setSchemeScheduleJob(scheduleJob);
                LogUtils.printLog(logger, "submit branchScheme process: {}", branchScheme.toString());
                branchSchemeExecutor = new BranchSchemeExecutor();
                branchSchemeExecutor.setBranchScheme(branchScheme);
                branchSchemeExecutor.setLogger(logger);

                pool.execute(branchSchemeExecutor);
                numberOfRecordProcessed++;
            }
            schemeJobLog.setNumberOfRecordProcessed(numberOfRecordProcessed);
            schemeJobLog.setStatus(JobProcessStatus.COMPLETE);

            LogUtils.printLog(logger, "job execute end... jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                    scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                    scheduleJob.getPollSchemeDirection());
        } catch (Exception e) {
            // TODO: handle exception
            LogUtils.printException(logger, "job execte exception:", e);
            if (schemeJobLog != null) {
                schemeJobLog.setStatus(JobProcessStatus.FAILED);
            }
        }
		if (schemeJobLog != null) {
			schemeJobLog.setEndTime(new Date());
			schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
		}

    }
    
	/**
	 * checkJobLog
	 * 
	 * Use the schedule ID to look up the Scheme Job Log
	 * 
	 * If there are no log, create a new one with Status = "PROGRESS"
	 * 
	 * If there are log there, check whether it is in "PROGRESS"
	 * 
	 *     Status = "PROGRESS"    ->   If the job within 1 hour return null
	 *                                 else marked last job LastJobInd as "N"
	 *                                                      Status as "Fail"
	 *                                 
	 *     Status <> "PROGRESS"   ->   Marked LastJobInd as "N"
	 *                                 
	 *     Create a new one with Status = "PROGRESS"
	 * 
	 * @param scheduleJob
	 * @return SchemeJobLog
	 */
    private SchemeJobLog checkJobLog(SchemeScheduleJob scheduleJob, Logger logger) {
//        SchemeJobLogQueryCriteria schemeJobLogQueryCriteria = new SchemeJobLogQueryCriteria();
//        schemeJobLogQueryCriteria.setScheduleJobId(scheduleJob.getId());

//        List<SchemeJobLog> schemeJobLogs = schedulerJobLogService.findSchemeJobLogByCriteria(schemeJobLogQueryCriteria);
        SchemeJobLog schemeJobLog = schedulerJobLogService.findLatestSchemeJobLog(scheduleJob.getId());
        if (schemeJobLog == null) {
            SchemeJobLog jobLog = new SchemeJobLog();
            jobLog.setLastJobInd(LatestJobInd.Y);
            jobLog.setStatus(JobProcessStatus.PROGRESS);
            jobLog.setStartTime(new Date());
            jobLog.setScheduleJobId(scheduleJob.getId());
            return schedulerJobLogService.addOrUpdateSchemeJobLog(jobLog);
        } else {
            if (schemeJobLog.getStatus() == JobProcessStatus.PROGRESS) {
				if(System.currentTimeMillis() - schemeJobLog.getLastUpdateTime().getTime() > 3600000) {
					LogUtils.printLog(logger, "scheduleJob={}  PROGRESS Continue 1 Hour", scheduleJob.getId());
					schemeJobLog.setStatus(JobProcessStatus.FAILED);
					schemeJobLog.setLastJobInd(LatestJobInd.N);
					schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
				} else {
                    LogUtils.printLog(logger, "scheduleJob={}  PROGRESS ING...", scheduleJob.getId());
                    return null;
                }

            } else {
                schemeJobLog.setLastJobInd(LatestJobInd.N);
                schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
            }

            SchemeJobLog jobLog = new SchemeJobLog();
            jobLog.setLastJobInd(LatestJobInd.Y);
            jobLog.setStatus(JobProcessStatus.PROGRESS);
            jobLog.setStartTime(new Date());
            jobLog.setScheduleJobId(scheduleJob.getId());
            jobLog = schedulerJobLogService.addOrUpdateSchemeJobLog(jobLog);
            return jobLog;
        }

    }

}
