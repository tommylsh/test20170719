package com.maxim.pos.common.service;

import java.math.BigDecimal;
import java.sql.Timestamp;
import java.time.LocalDateTime;
import java.time.ZoneId;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.annotation.Resource;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import org.slf4j.Logger;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Propagation;
import org.springframework.transaction.annotation.Transactional;

import com.maxim.pos.common.Auditer;
import com.maxim.pos.common.entity.BranchScheme;
import com.maxim.pos.common.entity.SchemeJobLog;
import com.maxim.pos.common.entity.SchemeScheduleJob;
import com.maxim.pos.common.entity.TaskJobLog;
import com.maxim.pos.common.enumeration.Direction;
import com.maxim.pos.common.enumeration.JobProcessStatus;
import com.maxim.pos.common.enumeration.LatestJobInd;
import com.maxim.pos.common.enumeration.PollSchemeType;
import com.maxim.pos.common.enumeration.TaskProcessStatus;
import com.maxim.pos.common.persistence.ApplicationSettingDao;
import com.maxim.pos.common.persistence.SchemeJobLogDao;
import com.maxim.pos.common.persistence.TaskJobLogDao;
import com.maxim.pos.common.util.LogUtils;
import com.maxim.pos.common.value.CommonCriteria;
import com.maxim.pos.sales.persistence.SchemeInfoDao;
import com.maxim.pos.security.entity.User;
import com.maxim.util.DateUtil;

@Service("schedulerJobLogService")
public class SchedulerJobLogServiceImpl implements SchedulerJobLogService {

	@PersistenceContext
	private EntityManager entityManager;
	
    @Autowired
    private SchemeJobLogDao schemeJobLogDao;
    
	@Autowired
	private SchemeInfoDao  schemeInfoDao;
	
    @Autowired
    private TaskJobLogDao taskJobLogDao;
	
    @Autowired
    ApplicationSettingDao applicationSettingDao ;
	
	@Resource(name="systemPrincipal")
	private User systemPrincipal;

	private @Value("${system.eod.batchProcessSize}")		int eodBatchProcessSize;
	private @Value("${system.realTime.batchProcessSize}")	int realTimeBatchProcessSize;
	private @Value("${system.master.batchProcessSize}")		int masterBatchProcessSize;
	private @Value("${system.other.batchProcessSize}")		int otherBatchProcessSize;
	private @Value("${system.numberOfMachine}")				int numberOfMachine;
	
	public Map<String, Boolean> eodPriorityMap = new HashMap<String, Boolean>();
	

    @Override
    @Transactional(readOnly = true)
    public List<SchemeJobLog> findSchemeJobLogByCriteria(CommonCriteria criteria) {
       return schemeJobLogDao.findSchemeJobLogByCriteria(criteria);
    }

    @Override
    @Transactional(readOnly = true)
    public SchemeJobLog findLatestSchemeJobLog(Long schedulerJobId) {
        return schemeJobLogDao.findLatestSchemeJobLog(schedulerJobId);
    }

    @Override
    @Transactional(propagation = Propagation.REQUIRES_NEW, readOnly = false)
    public SchemeJobLog addOrUpdateSchemeJobLog(SchemeJobLog schemeJobLog) {
        return schemeJobLogDao.addOrUpdateSchemeJobLog(schemeJobLog);
    }
    
    
    @Transactional(propagation = Propagation.REQUIRES_NEW, readOnly = false)
    public SchemeJobLog accquireSchemeJob(SchemeScheduleJob scheduleJob, Integer avaiable, Integer poolSize){
    	
////    	Integer obj = applicationSettingDao.getApplicationLock(scheduleJob.getPollSchemeType().name());
//    	Integer obj = applicationSettingDao.getApplicationLock();
//    	if (obj == null)
//    	{
//    		String code = "SCHEDULE" ;
//    		ApplicationSetting setting = new ApplicationSetting();
//    		setting.setCode(code);
//    		setting.setCodeDescription("Lock for " + code);
//    		setting.setCodeValue("LOCK");
//    		Auditer.audit(setting);
//    		applicationSettingDao.insert(setting);
//    	}
    	applicationSettingDao.getApplicationLock();
    	
    	Direction direction				= scheduleJob.getPollSchemeDirection();
    	PollSchemeType pollSchemeType	= scheduleJob.getPollSchemeType();

        SchemeJobLog lastSchemeJobLog = schemeJobLogDao.findLatestSchemeJobLog(scheduleJob.getId(), systemPrincipal.getUserId());
        if (lastSchemeJobLog != null) {
            LogUtils.printLog("lastSchemeJobLog={} {} {} {}", lastSchemeJobLog.getStatus(), lastSchemeJobLog.getLastUpdateTime() , System.currentTimeMillis() , lastSchemeJobLog.getLastUpdateTime().getTime());
//            if (lastSchemeJobLog.getStatus().equals(JobProcessStatus.PROGRESS) || lastSchemeJobLog.getStatus().equals(JobProcessStatus.PENDING)) {
//				if(System.currentTimeMillis() - lastSchemeJobLog.getLastUpdateTime().getTime() > 3600000) {
//					LogUtils.printLog("scheduleJob={}  PROGRESS Continue 1 Hour", scheduleJob.getId());
//					lastSchemeJobLog.setStatus(JobProcessStatus.FAILED);
//					lastSchemeJobLog.setLastJobInd(LatestJobInd.N);
//					schemeJobLogDao.addOrUpdateSchemeJobLog(lastSchemeJobLog);
//				} else {
//                    LogUtils.printLog("scheduleJob={}  PROGRESS ING...", scheduleJob.getId());
//                    return null;
//                }
//            } else {
//            	lastSchemeJobLog.setLastJobInd(LatestJobInd.N);
//                schemeJobLogDao.addOrUpdateSchemeJobLog(lastSchemeJobLog);
//            }
        	lastSchemeJobLog.setLastJobInd(LatestJobInd.N);
            schemeJobLogDao.addOrUpdateSchemeJobLog(lastSchemeJobLog);
        }

        SchemeJobLog schemeJobLog = new SchemeJobLog();
        
        schemeJobLog.setLastJobInd(LatestJobInd.Y);
        schemeJobLog.setStatus(JobProcessStatus.PENDING);
        schemeJobLog.setStartTime(new Date());
        schemeJobLog.setScheduleJobId(scheduleJob.getId());
        schemeJobLogDao.insertSchemeJobLog(schemeJobLog);
        
		List<Map<String, Object>> schemes = schemeInfoDao.findLatestPollBrachScheme(pollSchemeType, direction);

        List<BranchScheme> branchSchemeList = new ArrayList<BranchScheme>();
        
        long machineCount = 0 ;

        if (PollSchemeType.SALES_EOD.equals(pollSchemeType))
        {
    	    machineCount = schemeJobLogDao.countCreateUserByScheduleJobIdAndCreateUser(scheduleJob.getId(), systemPrincipal.getUserId());
      	    LogUtils.printLog("Active machineCount : {}", machineCount);
	
	        Collections.sort(schemes, new Comparator<Map<String, Object>>()
				{
					@Override
					public int compare(Map<String, Object> map1 ,Map<String, Object> map2) {
			            String branchCode1 = (String) map1.get("branchCode");
			            String branchCode2 = (String) map2.get("branchCode");
						if (eodPriorityMap.containsKey(branchCode1))
							return eodPriorityMap.containsKey(branchCode2) ? 0 : -1 ;
						else
							return eodPriorityMap.containsKey(branchCode2) ? 1 : 0 ;
					}
				}
	        );
        }
        for (Map<String, Object> map : schemes)
        {
            if (branchSchemeList.size() >= avaiable )
            {
            	break;
            }	
            
            
//        	Long id = decID.longValue() ;
//        	BranchScheme branchScheme = schemeInfoDao.getSingle(BranchScheme.class, id);
        	
        	BigDecimal pollBranchSchemeId = (BigDecimal) map.get("pollBranchSchemeId"); 
        	String pollSchemeName = (String) map.get("pollSchemeName"); 
        	BigDecimal pollBranchInfoId = (BigDecimal) map.get("pollBranchInfoId"); 
        	
        	Byte schemeEnabled = (Byte) map.get("schemeEnabled"); 
        	Byte infoEnabled = (Byte) map.get("infoEnabled"); 
        	Timestamp startTime = (Timestamp) map.get("startTime");
        	Timestamp endTime = (Timestamp) map.get("endTime");
            String branchCode = (String) map.get("branchCode");
            BigDecimal taskJobLogId = (BigDecimal) map.get("taskJobLogId");
            BigDecimal taskJobLogId2 = (BigDecimal) map.get("taskJobLogId2");
            String taskStatus = (String) map.get("status");
            String taskStatus2 = (String) map.get("status2");
            Timestamp taskLastUpdateTime = (Timestamp) map.get("lastUpdateTime");
            
            if (PollSchemeType.SALES_EOD.equals(pollSchemeType))
            {
	            if (branchSchemeList.size() >= (eodPriorityMap.size() / machineCount) + 1)
	            {
	    			if (eodPriorityMap.containsKey(branchCode))
	    			{
	    				continue ;
	    			}
	            }
            }
	            
			eodPriorityMap.remove(branchCode);

        	
//            if (!branchScheme.isEnabled()) {
            if (schemeEnabled == 0) {
                LogUtils.printLog("branchScheme is not enable :{}=={}=={}",
                		pollBranchSchemeId, pollSchemeType, direction);
//                		branchScheme.getId(), branchScheme.getPollSchemeName(),branchScheme.getPollSchemeType());
                continue;
//            } else if (!branchScheme.getBranchInfo().isEnable()) {
            } else if (infoEnabled == 0) {
                LogUtils.printLog("BranchInfo is not enable :{}=={}",
                		pollBranchSchemeId, pollSchemeType, direction);
//                		branchScheme.getBranchInfo().getId(), branchScheme.getBranchInfo().getClientDB());
                continue;
            }
//            String branchCode = branchScheme.getBranchMaster().getBranchCode();

			LocalDateTime now = LocalDateTime.now();
//			if (branchScheme.getStartTime() != null)
			if (startTime != null)
			{
				LocalDateTime start = startTime.toInstant().atZone(ZoneId.systemDefault())
						.toLocalDateTime();
				if (now.isBefore(start) ) {
                    LogUtils.printLog("branchScheme {}=={}=={}  invald execute datetime: startTime={},endTime={}",
                    		pollBranchSchemeId, pollSchemeType, direction, startTime, endTime);
//                            branchScheme.getId(),
//                            branchScheme.getPollSchemeName(),
//                            branchScheme.getPollSchemeType(),
//                            branchScheme.getStartTime(),
//                            branchScheme.getEndTime());
					continue;
				}
			}
			if (endTime != null)
			{
				LocalDateTime end = endTime.toInstant().atZone(ZoneId.systemDefault())
						.toLocalDateTime();
				if ( now.isAfter(end)) {
                    LogUtils.printLog("branchScheme {}=={}=={}  invald execute datetime: startTime={},endTime={}",
                    		pollBranchSchemeId, pollSchemeType, direction, startTime, endTime);
//                            branchScheme.getId(),
//                            branchScheme.getPollSchemeName(),
//                            branchScheme.getPollSchemeType(),
//                            branchScheme.getStartTime(),
//                            branchScheme.getEndTime());
					continue;
				}
			}
			
//	        TaskJobLog lastTaskJobLog = taskJobLogDao.findLatestTaskJobLog(direction, id, pollSchemeType, branchCode);
//			TaskJobLog lastTaskJobLog = taskJobLogDao.findByKey(taskJobLogId);

	        if (taskJobLogId != null) {
//	            LogUtils.printLog("lastTaskJobLog={} {} {} {}", lastTaskJobLog.getStatus(), lastTaskJobLog.getLastUpdateTime() , System.currentTimeMillis() , lastTaskJobLog.getLastUpdateTime().getTime());
	            LogUtils.printLog("lastTaskJobLog={} {} {} {}", taskStatus, taskLastUpdateTime , System.currentTimeMillis() , taskLastUpdateTime.getTime());
	            if (taskStatus.equals(TaskProcessStatus.PROGRESS.name()) || taskStatus.equals(TaskProcessStatus.PENDING.name())) {
	            	if(System.currentTimeMillis() - taskLastUpdateTime.getTime() > 3600000){
						LogUtils.printLog("{} branch code process continue 1 hour ,auto update status  to failed ",
								branchCode);
//						lastTaskJobLog.setStatus(TaskProcessStatus.FAILED);
////						lastTaskJobLog.setLastestJobInd(LatestJobInd.N);
//				        Auditer.audit(lastTaskJobLog);
//			            taskJobLogDao.update(lastTaskJobLog);
					} else {
						LogUtils.printLog("{} branch code process within 1 hour ,skipped ",
								branchCode);
						continue;
					}
	            }
	        }
	        if (taskJobLogId2 != null) {
	            if (taskStatus2.equals(TaskProcessStatus.PROGRESS.name()) || taskStatus2.equals(TaskProcessStatus.PENDING.name())) {
	            	if(System.currentTimeMillis() - taskLastUpdateTime.getTime() > 3600000){
						LogUtils.printLog("{} branch code second process continue 1 hour ,auto update status  to failed ",
								branchCode);
					} else {
						LogUtils.printLog("{} branch code second process within 1 hour ,skipped ",
								branchCode);
						continue;
					}
	            }
	        }
	            
	        TaskJobLog taskLog = new TaskJobLog();
	        taskLog.setLastestJobInd(LatestJobInd.P);
	        taskLog.setStatus(TaskProcessStatus.PENDING);
	        taskLog.setStartTime(new Date());
	        Auditer.audit(taskLog);
//	        taskLog.setSchemeScheduleJob(scheduleJob);
	        taskLog.setScheduleJobId(scheduleJob.getId());
	        taskLog.setPollSchemeID(pollBranchSchemeId.longValue());
	        taskLog.setDirection(direction);
	        taskLog.setPollSchemeType(pollSchemeType);
	        taskLog.setSchemeJobLog(schemeJobLog);
	        
	        taskLog.setBranchCode(branchCode);
	        taskLog.setPollBranchId(pollBranchInfoId.longValue());
	        taskLog.setPollSchemeName(pollSchemeName);
	        taskLog.setSchemeJobLog(schemeJobLog);
	        
	        taskJobLogDao.insert(taskLog);
//	        taskJobLogDao.purgeTaskJobLog(direction, branchScheme.getId(), pollSchemeType, branchCode, TaskProcessStatus.NONE);

	        
//	        taskLog.setLastTaskJobLog(lastTaskJobLog);
	        if (taskJobLogId != null)
	        {
	        	taskLog.setLastTaskJobLogId(taskJobLogId.longValue());
	        }
	        if (taskJobLogId2 != null)
	        {
	        	taskLog.setLastDependTaskJobLogId(taskJobLogId2.longValue());
	        }

        	BranchScheme branchScheme = new BranchScheme() ;
        	
        	branchScheme.setId(pollBranchSchemeId.longValue());
            branchScheme.setSchemeScheduleJob(scheduleJob);
            branchScheme.setTaskLog(taskLog);
            
            branchSchemeList.add(branchScheme);
            
			LogUtils.printLog("Prepare Submit Branch : {} ",
					branchCode);
			
		
//
//            
//            if (PollSchemeType.SALES_EOD.equals(pollSchemeType))
//            {
//                if (branchSchemeList.size() >= eodBatchProcessSize)
//                {
//                	break;
//                }
//            }
//            else if (PollSchemeType.SALES_REALTIME.equals(pollSchemeType))
//            {
//                if (branchSchemeList.size() >= realTimeBatchProcessSize)
//                {
//                	break;
//                }
//            }
//            else if (PollSchemeType.MASTER.equals(pollSchemeType))
//            {
//                if (branchSchemeList.size() >= masterBatchProcessSize)
//                {
//                	break;
//                }
//            }
//            else
//            {
//                if (branchSchemeList.size() >= otherBatchProcessSize)
//                {
//                	break;
//                }
//            }
            

        }
        
        schemeJobLog.setBranchSchemeList(branchSchemeList);
        
        entityManager.flush();
        entityManager.clear();    	

    	return schemeJobLog;
    }
    
	/**
	 * checkJobLog
	 * 
	 * Use the schedule ID to look up the Scheme Job Log
	 * 
	 * If there are no log, create a new one with Status = "PROGRESS"
	 * 
	 * If there are log there, check whether it is in "PROGRESS"
	 * 
	 *     Status = "PROGRESS"    ->   If the job within 1 hour return null
	 *                                 else marked last job LastJobInd as "N"
	 *                                                      Status as "Fail"
	 *                                 
	 *     Status <> "PROGRESS"   ->   Marked LastJobInd as "N"
	 *                                 
	 *     Create a new one with Status = "PROGRESS"
	 * 
	 * @param scheduleJob
	 * @return SchemeJobLog
	 */
    @Transactional(propagation = Propagation.REQUIRES_NEW, readOnly = false)
    public SchemeJobLog checkJobLog(SchemeScheduleJob scheduleJob, long interval, Logger logger) {
//        SchemeJobLogQueryCriteria schemeJobLogQueryCriteria = new SchemeJobLogQueryCriteria();
//        schemeJobLogQueryCriteria.setScheduleJobId(scheduleJob.getId());

//        List<SchemeJobLog> schemeJobLogs = schedulerJobLogService.findSchemeJobLogByCriteria(schemeJobLogQueryCriteria);
    	Timestamp currentTimetamp = DateUtil.getCurrentTimestamp();

    	applicationSettingDao.getApplicationLock();

        SchemeJobLog schemeJobLog = schemeJobLogDao.findLatestSchemeJobLog(scheduleJob.getId());
        if (schemeJobLog == null) {
            SchemeJobLog jobLog = new SchemeJobLog();
            jobLog.setLastJobInd(LatestJobInd.Y);
            jobLog.setStatus(JobProcessStatus.PROGRESS);
            jobLog.setStartTime(new Date());
            jobLog.setScheduleJobId(scheduleJob.getId());
            return schemeJobLogDao.addOrUpdateSchemeJobLog(jobLog);
        } else {
        	Date lastSchemeTime = schemeJobLog.getCreateTime() ;
			LogUtils.printLog(logger, "scheduleJob={} currentTimetamp={}  lastSchemeTime ={} currentTimetamp={} lastSchemeTime={} diff: {} / {}", 
					scheduleJob.getId(), currentTimetamp, lastSchemeTime, currentTimetamp.getTime(), lastSchemeTime.getTime(), currentTimetamp.getTime() - lastSchemeTime.getTime(), interval);
        	if (currentTimetamp.getTime() - lastSchemeTime.getTime() < interval / 2)
        	{
                LogUtils.printLog(logger, "scheduleJob={}  PROGRESSED...", scheduleJob.getId());
                return null;
        	}
        	
            if (schemeJobLog.getStatus() == JobProcessStatus.PROGRESS) {
				if(System.currentTimeMillis() - schemeJobLog.getLastUpdateTime().getTime() > 3600000) {
					LogUtils.printLog(logger, "scheduleJob={}  PROGRESS Continue 1 Hour", scheduleJob.getId());
					schemeJobLog.setStatus(JobProcessStatus.FAILED);
					schemeJobLog.setLastJobInd(LatestJobInd.N);
					schemeJobLogDao.addOrUpdateSchemeJobLog(schemeJobLog);
				} else {
                    LogUtils.printLog(logger, "scheduleJob={}  PROGRESS ING...", scheduleJob.getId());
                    return null;
                }

            } else {
                schemeJobLog.setLastJobInd(LatestJobInd.N);
                schemeJobLogDao.addOrUpdateSchemeJobLog(schemeJobLog);
            }

            SchemeJobLog jobLog = new SchemeJobLog();
            jobLog.setLastJobInd(LatestJobInd.Y);
            jobLog.setStatus(JobProcessStatus.PROGRESS);
            jobLog.setStartTime(new Date());
            jobLog.setScheduleJobId(scheduleJob.getId());
            jobLog = schemeJobLogDao.addOrUpdateSchemeJobLog(jobLog);
            return jobLog;
        }

    }
    
    public void higherEodPriority(String branchCode)
    {
    	eodPriorityMap.put(branchCode, Boolean.TRUE);
    }
    
}
