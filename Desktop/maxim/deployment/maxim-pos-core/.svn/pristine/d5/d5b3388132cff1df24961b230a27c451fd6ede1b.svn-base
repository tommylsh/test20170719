package com.maxim.pos.common.service;

import java.io.File;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;
import java.util.concurrent.FutureTask;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;

import javax.annotation.PostConstruct;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;

import com.maxim.pos.common.entity.ApplicationSetting;
import com.maxim.pos.common.entity.BranchScheme;
import com.maxim.pos.common.entity.SchemeJobLog;
import com.maxim.pos.common.entity.SchemeScheduleJob;
import com.maxim.pos.common.entity.TaskJobLog;
import com.maxim.pos.common.enumeration.JobProcessStatus;
import com.maxim.pos.common.enumeration.LatestJobInd;
import com.maxim.pos.common.enumeration.PollSchemeType;
import com.maxim.pos.common.persistence.TaskJobLogDao;
import com.maxim.pos.common.util.LogUtils;
import com.maxim.pos.common.util.PollThreadPoolExecutor;
import com.maxim.pos.sales.persistence.SchemeInfoDao;

@Service("schemeQuartzTaskExecutor")
public class SchemeQuartzTaskExecutor {
    public static final Logger LOGGER = LoggerFactory.getLogger(SchemeQuartzTaskExecutor.class);
    //	private static ExecutorService EXECUTOR_SERVICE;
    private static Map<String,PollThreadPoolExecutor>  poolMap = new HashMap<String,PollThreadPoolExecutor>();
    
    private static String STATE_LOCKING	= "LOCKING";
    private static String STATE_IDLE	= "IDLE";
    
    private static Map<Long,String>  controlMap = new HashMap<Long,String>();

    private static int poolSize = 100;
//    @Autowired
//    private PollBranchSchemeService pollBranchSchemeService;
    @Autowired
    private SchedulerJobLogService schedulerJobLogService;
//    @Autowired
//    private PosSystemService posSystemService;
    @Autowired
    private ApplicationSettingService applicationSettingService;
    
    @Autowired
	private SchemeInfoDao  schemeInfoDao;
	
    @Autowired
    private TaskJobLogDao taskJobLogDao;
	
	private @Value("${system.eod.batchProcessSize}") int eodBatchProcessSize;
	private @Value("${system.realTime.batchProcessSize}") int realTimeBatchProcessSize;
	private @Value("${system.master.batchProcessSize}") int masterBatchProcessSize;
	private @Value("${system.other.batchProcessSize}") int otherBatchProcessSize;

    @PostConstruct
    public void init() throws Exception {
    	File file = new File(".");
    	System.out.println("*********************************************************");
    	System.out.println(file.getAbsolutePath());
    	System.out.println("*********************************************************");
        ApplicationSetting applicationSetting = applicationSettingService
                .findApplicationSettingByCode("BRANCH_EXECUTE_THREADPOOL_SIZE");
//        int poolSize = 100;
        if (applicationSetting != null) {
            String pool = applicationSetting.getCodeValue();
            try {
                poolSize = Integer.parseInt(pool);
            } catch (Exception e) {
                LOGGER.error("BRANCH_EXECUTE_THREADPOOL config Error,must number", e);
            }
        }
        
//        pool = new PollThreadPoolExecutor(poolSize, poolSize, 50,
//                TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());

    }

    public void execute(SchemeScheduleJob scheduleJob) {

        boolean locking = false ;

        Logger logger = null;
        SchemeJobLog schemeJobLog = null;
        List<Future<Boolean>> futures = null ;
        
        int batchProcessSize = otherBatchProcessSize ;
        
        try {
            switch (scheduleJob.getPollSchemeType()) {
                case SALES_REALTIME:
                    logger = LogUtils.SALES_REALTIME_LOGGER;
                    batchProcessSize = realTimeBatchProcessSize ;
                    break;
                case SALES_EOD:
                    logger = LogUtils.SALES_EOD_LOGGER;
                    batchProcessSize = eodBatchProcessSize ;
                    break;
                case MASTER:
                    logger = LogUtils.MASTER_LOGGER;
                    batchProcessSize = masterBatchProcessSize ;
                    break;
                case SMTP:
                    logger = LogUtils.MASTER_LOGGER;
                    break;
                default:
                    logger = LOGGER;
                    break;
            }
            LogUtils.setCurrentThreadLogger(logger);
            
            synchronized(controlMap)
            {
            	String state = controlMap.get(scheduleJob.getId());
            	if (state== null)
            	{
            		state = STATE_IDLE ;
            	}
            	if (STATE_LOCKING.equals(state))
            	{
                    LogUtils.printLog(logger,
                            "Last Job is Running : jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                            scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                            scheduleJob.getPollSchemeDirection());
                    return;
            	}
            	controlMap.put(scheduleJob.getId(), STATE_LOCKING);
            	locking = true ;
            }
            
            
            if (!scheduleJob.isEnable()) {
                LogUtils.printLog(logger,
                        "job is not enable : jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                        scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                        scheduleJob.getPollSchemeDirection());
                return;
            }

            LogUtils.printLog(logger,
                    "job execute start... jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                    scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                    scheduleJob.getPollSchemeDirection());
            
            PollThreadPoolExecutor pool = poolMap.get(scheduleJob.getPollSchemeType().name()) ;
            if (pool == null)
            {
                pool = new PollThreadPoolExecutor(batchProcessSize, batchProcessSize, 50,
                        TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>());
                
                poolMap.put(scheduleJob.getPollSchemeType().name(),pool);
            }
            
            schemeJobLog = null;
            int numberOfRecordProcessed = 0;
            if (scheduleJob.getPollSchemeType().equals(PollSchemeType.SMTP))
            {
                schemeJobLog = checkJobLog(scheduleJob, logger);
                if (schemeJobLog == null) {
                    return;
                }

            	BranchSchemeExecutor branchSchemeExecutor = new BranchSchemeExecutor();
                BranchScheme branchScheme = new BranchScheme();
                branchScheme.setPollSchemeType(scheduleJob.getPollSchemeType());
                branchScheme.setDirection(scheduleJob.getPollSchemeDirection());
                branchSchemeExecutor.setSchemeJobLog(schemeJobLog);
                branchSchemeExecutor.setBranchScheme(branchScheme);
                branchSchemeExecutor.setLogger(logger);

                
//                Future<Boolean> fReturn = pool.submit(branchSchemeExecutor, Boolean.TRUE);
                
                Future<Boolean> fReturn = new FutureTask<Boolean>(branchSchemeExecutor, Boolean.TRUE);
                
                futures = new ArrayList<Future<Boolean>>(1);
                futures.add(fReturn);
                

            }
            else
            {
                LogUtils.printLog(logger, "Pool Size {} / {} / {}",pool.getActiveCount() ,pool.getPoolSize() ,batchProcessSize);
                if (batchProcessSize - pool.getActiveCount() <= 0)
                {
                    LogUtils.printLog(logger, "Pool is Full, exit {} / {} /{} ",pool.getActiveCount() ,pool.getPoolSize() ,batchProcessSize);
                    return ;
                }
                schemeJobLog = schedulerJobLogService.accquireSchemeJob(scheduleJob, batchProcessSize - pool.getActiveCount(), batchProcessSize);
                if (schemeJobLog == null) {
                    return;
                }
            	
//                List<BranchScheme> branchSchemes = pollBranchSchemeService.getBranchSchemeByScheduleJob(scheduleJob);
                List<BranchScheme> branchSchemes = schemeJobLog.getBranchSchemeList();
                BranchSchemeExecutor branchSchemeExecutor;
                
                futures = new ArrayList<Future<Boolean>>(branchSchemes.size());
                
                for (BranchScheme branchScheme : branchSchemes) {
//                    if (!branchScheme.isEnabled()) {
//                        LogUtils.printLog(logger, "branchScheme is not enable :{}=={}=={}", branchScheme.getId(),
//                                branchScheme.getPollSchemeName(),branchScheme.getPollSchemeType());
//                        continue;
//                    } else if (!branchScheme.getBranchInfo().isEnable()) {
//                        LogUtils.printLog(logger, "BranchInfo is not enable :{}=={}", branchScheme.getBranchInfo().getId(),
//                                branchScheme.getBranchInfo().getClientDB());
//                        continue;
//                    }
////                    } else {
////                        LocalDateTime now = LocalDateTime.now();
////                        LocalDateTime start = branchScheme.getStartTime().toInstant().atZone(ZoneId.systemDefault())
////                                .toLocalDateTime();
////                        LocalDateTime end = branchScheme.getEndTime().toInstant().atZone(ZoneId.systemDefault())
////                                .toLocalDateTime();
////                        if (now.isBefore(start) || now.isAfter(end)) {
////                            LogUtils.printLog(logger, "branchScheme {}=={}=={}  invald execute datetime: startTime={},endTime={}",
////                                    branchScheme.getId(),
////                                    branchScheme.getPollSchemeName(),
////                                    branchScheme.getPollSchemeType(),
////                                    branchScheme.getStartTime(),
////                                    branchScheme.getEndTime());
////                            continue;
////                        }
//    //
////                    }
//
//    				LocalDateTime now = LocalDateTime.now();
//    				if (branchScheme.getStartTime() != null)
//    				{
//    					LocalDateTime start = branchScheme.getStartTime().toInstant().atZone(ZoneId.systemDefault())
//    							.toLocalDateTime();
//    					if (now.isBefore(start) ) {
//                            LogUtils.printLog(logger, "branchScheme {}=={}=={}  invald execute datetime: startTime={},endTime={}",
//                                    branchScheme.getId(),
//                                    branchScheme.getPollSchemeName(),
//                                    branchScheme.getPollSchemeType(),
//                                    branchScheme.getStartTime(),
//                                    branchScheme.getEndTime());
//    						continue;
//    					}
//    				}
//    				if (branchScheme.getEndTime() != null)
//    				{
//    					LocalDateTime end = branchScheme.getEndTime().toInstant().atZone(ZoneId.systemDefault())
//    							.toLocalDateTime();
//    					if ( now.isAfter(end)) {
//                            LogUtils.printLog(logger, "branchScheme {}=={}=={}  invald execute datetime: startTime={},endTime={}",
//                                    branchScheme.getId(),
//                                    branchScheme.getPollSchemeName(),
//                                    branchScheme.getPollSchemeType(),
//                                    branchScheme.getStartTime(),
//                                    branchScheme.getEndTime());
//    						continue;
//    					}
//    				}
//
//                    branchScheme.setSchemeScheduleJob(scheduleJob);
                    LogUtils.printLog(logger, "submit branchScheme process: {}", branchScheme.toString());
                    branchSchemeExecutor = new BranchSchemeExecutor();
                    BranchScheme thisBranchScheme = schemeInfoDao.getSingle(BranchScheme.class, branchScheme.getId());
                    
                    TaskJobLog taskJobLog = branchScheme.getTaskLog() ;
                    
                    thisBranchScheme.setSchemeScheduleJob(scheduleJob);
                    thisBranchScheme.setTaskLog(taskJobLog);
                    
                    branchSchemeExecutor.setSchemeJobLog(schemeJobLog);
                    branchSchemeExecutor.setBranchScheme(thisBranchScheme);
                    branchSchemeExecutor.setLogger(logger);

                    Future<Boolean> fReturn = pool.submit(branchSchemeExecutor, Boolean.TRUE);
                    futures.add(fReturn);
                    numberOfRecordProcessed++;
                }
            }
            schemeJobLog.setNumberOfRecordProcessed(numberOfRecordProcessed);
            schemeJobLog.setStatus(JobProcessStatus.PROGRESS);

            LogUtils.printLog(logger, "job execute end... jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                    scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                    scheduleJob.getPollSchemeDirection());
        } catch (Exception e) {
            LogUtils.printException(logger, "job execte exception:", e);
            if (schemeJobLog != null) {
				schemeJobLog.setEndTime(new Date());
				schemeJobLog.setStatus(JobProcessStatus.FAILED);
            }
            return ;
        }
        finally
        {
            synchronized(controlMap)
            {
            	if (locking)
            	{
            		controlMap.put(scheduleJob.getId(), STATE_IDLE);
            	}
            }
            if (schemeJobLog != null) {
				schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
            }
    	}

        boolean done = false ;
        try
        {
            LogUtils.printLog(logger, "job wait start ... jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                    scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                    scheduleJob.getPollSchemeDirection());
        	long start = System.currentTimeMillis();
	        for (Future<Boolean> fReturn : futures)
	        {
	        	long current = System.currentTimeMillis() - start ;
				try {
//		            LogUtils.printLog(logger, "job wait for {} ... jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
//		            		current, scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
//		                    scheduleJob.getPollSchemeDirection());						
		            fReturn.get(1800000 - current, TimeUnit.MILLISECONDS);
				} catch (TimeoutException e) {
		            LogUtils.printLog(logger, "job wait timout ... jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
		                    scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
		                    scheduleJob.getPollSchemeDirection());				
					fReturn.cancel(true);
				}
	        }
            LogUtils.printLog(logger, "job wait end ... jobId={},jobName={},pollSchemeType={},pollSchemeDirection={}",
                    scheduleJob.getId(), scheduleJob.getJobName(), scheduleJob.getPollSchemeType(),
                    scheduleJob.getPollSchemeDirection());
            
            schemeJobLog.setStatus(JobProcessStatus.COMPLETE);
			if (schemeJobLog != null) {
				schemeJobLog.setEndTime(new Date());
				schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
			}
			done = true ;
		} catch (InterruptedException | ExecutionException e) {
            LogUtils.printException(logger, "job wait exception:", e);
			if (schemeJobLog != null) {
				schemeJobLog.setEndTime(new Date());
				schemeJobLog.setStatus(JobProcessStatus.FAILED);
				schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
			}
			done = true ;
		}
        finally
        {

        	if (!done)
        	{
    			if (schemeJobLog != null) {
    				schemeJobLog.setEndTime(new Date());
    				schemeJobLog.setStatus(JobProcessStatus.FAILED);
    				schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
    			}
        	}
        }

    }
    
	/**
	 * checkJobLog
	 * 
	 * Use the schedule ID to look up the Scheme Job Log
	 * 
	 * If there are no log, create a new one with Status = "PROGRESS"
	 * 
	 * If there are log there, check whether it is in "PROGRESS"
	 * 
	 *     Status = "PROGRESS"    ->   If the job within 1 hour return null
	 *                                 else marked last job LastJobInd as "N"
	 *                                                      Status as "Fail"
	 *                                 
	 *     Status <> "PROGRESS"   ->   Marked LastJobInd as "N"
	 *                                 
	 *     Create a new one with Status = "PROGRESS"
	 * 
	 * @param scheduleJob
	 * @return SchemeJobLog
	 */
    private SchemeJobLog checkJobLog(SchemeScheduleJob scheduleJob, Logger logger) {
//        SchemeJobLogQueryCriteria schemeJobLogQueryCriteria = new SchemeJobLogQueryCriteria();
//        schemeJobLogQueryCriteria.setScheduleJobId(scheduleJob.getId());

//        List<SchemeJobLog> schemeJobLogs = schedulerJobLogService.findSchemeJobLogByCriteria(schemeJobLogQueryCriteria);
        SchemeJobLog schemeJobLog = schedulerJobLogService.findLatestSchemeJobLog(scheduleJob.getId());
        if (schemeJobLog == null) {
            SchemeJobLog jobLog = new SchemeJobLog();
            jobLog.setLastJobInd(LatestJobInd.Y);
            jobLog.setStatus(JobProcessStatus.PROGRESS);
            jobLog.setStartTime(new Date());
            jobLog.setScheduleJobId(scheduleJob.getId());
            return schedulerJobLogService.addOrUpdateSchemeJobLog(jobLog);
        } else {
            if (schemeJobLog.getStatus() == JobProcessStatus.PROGRESS) {
				if(System.currentTimeMillis() - schemeJobLog.getLastUpdateTime().getTime() > 3600000) {
					LogUtils.printLog(logger, "scheduleJob={}  PROGRESS Continue 1 Hour", scheduleJob.getId());
					schemeJobLog.setStatus(JobProcessStatus.FAILED);
					schemeJobLog.setLastJobInd(LatestJobInd.N);
					schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
				} else {
                    LogUtils.printLog(logger, "scheduleJob={}  PROGRESS ING...", scheduleJob.getId());
                    return null;
                }

            } else {
                schemeJobLog.setLastJobInd(LatestJobInd.N);
                schedulerJobLogService.addOrUpdateSchemeJobLog(schemeJobLog);
            }

            SchemeJobLog jobLog = new SchemeJobLog();
            jobLog.setLastJobInd(LatestJobInd.Y);
            jobLog.setStatus(JobProcessStatus.PROGRESS);
            jobLog.setStartTime(new Date());
            jobLog.setScheduleJobId(scheduleJob.getId());
            jobLog = schedulerJobLogService.addOrUpdateSchemeJobLog(jobLog);
            return jobLog;
        }

    }
    


}
