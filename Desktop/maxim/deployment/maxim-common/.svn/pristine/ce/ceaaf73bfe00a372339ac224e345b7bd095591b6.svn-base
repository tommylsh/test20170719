package com.maxim.dao;

import java.beans.PropertyDescriptor;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.sql.Date;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import javax.persistence.Column;
import javax.persistence.Id;
import javax.persistence.Table;

import org.springframework.beans.BeanUtils;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource;
import org.springframework.jdbc.core.namedparam.MapSqlParameterSource;
import org.springframework.jdbc.core.namedparam.SqlParameterSource;

public class JdbcResultSetExtrator<T,K> {

	protected Class<T> dtoClass = null ;
	protected Class<K> keyClass = null ;
	
	protected String tableName = null ;
	protected String[] colNames = null ;
	protected Map<String, Method> getterMap = null ;
	protected Map<String, Method> setterMap = null ;

	protected boolean keyPrimitive = true ;
	protected String primitiveColumn = null ;
	protected String seletAllColumns = null ;
	protected String keyClause = null ;
	protected String selectAllSql = null ;
	protected String selectByKeySql = null ;
	protected String updateByKeySql = null ;
	protected String deleteByKeySql = null ;
	protected String insertSql = null ;
	
	protected RowMapper<T> mapper = null ;
	
    protected JdbcResultSetExtrator(Class<T> dtoClass, Class<K> keyClass) {
        this.dtoClass = dtoClass;
        this.keyClass = keyClass;
        init();
    }	
    
	@SuppressWarnings("unchecked")
	protected JdbcResultSetExtrator() {
    	Type genericSuperclass = this.getClass().getGenericSuperclass();

        if (genericSuperclass instanceof ParameterizedType) {
            ParameterizedType pt = (ParameterizedType) genericSuperclass;
            Type type = pt.getActualTypeArguments()[0];
            dtoClass = (Class<T>) type;
            type = pt.getActualTypeArguments()[1];
            keyClass = (Class<K>) type;
        }
//        this.typeParameterClass = typeParameterClass;
        init();
    }
	
	public void init()
	{
        PropertyDescriptor[] pds = BeanUtils.getPropertyDescriptors(dtoClass);
        Table tableAnnotaion = dtoClass.getAnnotation(Table.class);
        if (tableAnnotaion == null)
        {
        	return ;
        }
        this.tableName = tableAnnotaion.name();
        
//    	Java primitive type; any primitive wrapper type; String; java.util.Date; java.sql.Date; java.math.BigDecimal; java.math.BigInteger. 
        if (keyClass.isPrimitive() || keyClass.equals(String.class) || keyClass.equals(Date.class) || keyClass.equals(BigDecimal.class) || keyClass.equals(BigInteger.class) )
        {
        	keyPrimitive = true ;
        }
        else
        {
        	keyPrimitive = false ; 
        }
        
        Map<String, Method> getterMap = new HashMap<String, Method>();
        Map<String, Method> setterMap = new HashMap<String, Method>();
        List<Column> colList = new ArrayList<Column>();
        List<PropertyDescriptor> keyList = new ArrayList<PropertyDescriptor>();
        StringBuffer selectAllColunmBuffer = new StringBuffer();
        StringBuffer keyClauseBuffer = new StringBuffer();
        StringBuffer updateColunmBuffer = new StringBuffer();
        StringBuffer insertColunmBuffer = new StringBuffer();
        
        System.out.println(" PropertyDescriptor " + pds.length);
        for (PropertyDescriptor pd : pds)
        {
        	Method getter = pd.getReadMethod();
        	Column colunmAnnotaion = getter.getAnnotation(Column.class);
            System.out.println(" colunmAnnotaion " +pd.getName());
        	if (colunmAnnotaion != null)
        	{
        		String colunmName = colunmAnnotaion.name() ;
        		colList.add(colunmAnnotaion);

                System.out.println(" colunmAnnotaion " +colunmName);

        		getterMap.put(colunmName, getter);
        		setterMap.put(colunmName, pd.getWriteMethod());
        		
        		selectAllColunmBuffer.append(colunmName).append(",");
        		insertColunmBuffer.append(":").append(pd.getName()).append(",");
            	Id idAnnotaion = getter.getAnnotation(Id.class);
                System.out.println(" idAnnotaion " +idAnnotaion);
            	if (idAnnotaion != null)
            	{
            		if (keyPrimitive)
            		{
            			primitiveColumn = colunmName ;
            		}
        			PropertyDescriptor pdKey = BeanUtils.getPropertyDescriptor(keyClass, pd.getName());
            		keyList.add(pdKey);
        			keyClauseBuffer.append(colunmName).append(" = :").append(pd.getName()).append(" and ");
            	}
            	else
            	{
            		updateColunmBuffer.append(colunmName).append(" = :").append(pd.getName()).append(",");
            	}
        	}
        }
        seletAllColumns = selectAllColunmBuffer.toString() ;
        seletAllColumns = seletAllColumns.substring(0, seletAllColumns.length()-1);
        String updateColunms = updateColunmBuffer.toString();
        updateColunms = updateColunms.substring(0, updateColunms.length()-1);
        String insertColunm = insertColunmBuffer.toString();
        insertColunm = insertColunm.substring(0, insertColunm.length()-1);
        
        if (!keyList.isEmpty())
        {
	        keyClause = keyClauseBuffer.toString() ;
	        keyClause = keyClause.substring(0, keyClause.length()-5);

	        selectByKeySql	= "SELECT " + seletAllColumns + " FROM " + tableName + " WHERE " + keyClause;
	        deleteByKeySql	= "DELETE FROM " + tableName + " WHERE " + keyClause;
	        updateByKeySql	= "UPDATE " + tableName + " SET " + updateColunms + " WHERE " + keyClause;
        }

        selectAllSql	= "SELECT " + seletAllColumns + " FROM " + tableName ;
        insertSql		= "INSERT INTO " + tableName + "(" + seletAllColumns + ") VALUES (" + insertColunm + ")";
        
        int i = 0 ;
        colNames = new String[colList.size()];
        for (Column col : colList)
        {
        	colNames[i++] = col.name();
        }
        
        mapper = new RowMapper<T>()
        		{

					@Override
					public T mapRow(ResultSet rs, int rowNum) throws SQLException {
						try {
							T obj = dtoClass.newInstance() ;
							for (String colname : colNames)
							{
								Method setter = setterMap.get(colname);
								Class<?>[] types  = setter.getParameterTypes();
								Class<?> argClass = types[0];
								if (argClass.equals(String.class))
								{
									String data = rs.getString(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(BigDecimal.class))
								{
									BigDecimal data = rs.getBigDecimal(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Byte.class))
								{
									Byte data = rs.getByte(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(java.sql.Date.class))
								{
									java.util.Date data = rs.getTimestamp(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Date.class))
								{
									Date data = rs.getDate(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Double.class))
								{
									Double data = rs.getDouble(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Integer.class))
								{
									Integer data = rs.getInt(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Float.class))
								{
									Float data = rs.getFloat(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Long.class))
								{
									Long data = rs.getLong(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Short.class))
								{
									Short data = rs.getShort(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Time.class))
								{
									Time data = rs.getTime(colname);
									setter.invoke(obj, data);
								} else if (argClass.equals(Timestamp.class))
								{
									Timestamp data = rs.getTimestamp(colname);
									setter.invoke(obj, data);
								} else 
								{
									Object data = rs.getObject(colname);
									setter.invoke(obj, data);
								}
							}
							return obj;
						} 
						catch (IllegalAccessException | InstantiationException | IllegalArgumentException | InvocationTargetException e) {
							e.printStackTrace();
						}
						return null;
						
					}
        	
        		};
	}
	
	 
//	
//	@Override
//	public List<T> extractData(ResultSet rs) throws SQLException {
//
//		List<T> results = new ArrayList<T>();
//		while (rs.next()) {
//			try {
//				T obj = this.dtoClass.newInstance() ;
//				for (String colname : colNames)
//				{
//					Method setter = this.setterMap.get(colname);
//					Class<?>[] types  = setter.getParameterTypes();
//					Class<?> argClass = types[0];
//					if (argClass.equals(String.class))
//					{
//						String data = rs.getString(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(BigDecimal.class))
//					{
//						BigDecimal data = rs.getBigDecimal(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Byte.class))
//					{
//						Byte data = rs.getByte(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Date.class))
//					{
//						Date data = rs.getDate(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Double.class))
//					{
//						Double data = rs.getDouble(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Integer.class))
//					{
//						Integer data = rs.getInt(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Float.class))
//					{
//						Float data = rs.getFloat(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Long.class))
//					{
//						Long data = rs.getLong(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Short.class))
//					{
//						Short data = rs.getShort(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Time.class))
//					{
//						Time data = rs.getTime(colname);
//						setter.invoke(obj, data);
//					} else if (argClass.equals(Timestamp.class))
//					{
//						Timestamp data = rs.getTimestamp(colname);
//						setter.invoke(obj, data);
//					} else 
//					{
//						Object data = rs.getObject(colname);
//						setter.invoke(obj, data);
//					}
//				}
//				results.add(obj);
//			} 
//			catch (IllegalAccessException | InstantiationException | IllegalArgumentException | InvocationTargetException e) {
//				e.printStackTrace();
//			}
//		}
//		return results;
//	}
	
	public SqlParameterSource getKeyParameterSource(K key)
	{
		if (this.keyPrimitive)
		{
			HashMap<String, K> map = new HashMap<String, K>();
			map.put(primitiveColumn, key);
			return new MapSqlParameterSource(map);
		}
		else
		{
			return new BeanPropertySqlParameterSource(key);
		}
		
	}
	
	public SqlParameterSource geParameterSource(T obj)
	{
		return new BeanPropertySqlParameterSource(obj);
	}
}
